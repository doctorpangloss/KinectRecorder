<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Emgu.CV.GPU</name>
    </assembly>
    <members>
        <member name="T:Emgu.CV.GPU.GpuBruteForceMatcher">
            <summary>
            A Brute force matcher using GPU
            </summary>
        </member>
        <member name="M:Emgu.CV.GPU.GpuBruteForceMatcher.#ctor(Emgu.CV.GPU.GpuBruteForceMatcher.DistanceType)">
            <summary>
            Create a GPUBruteForce Matcher using the specific distance type
            </summary>
            <param name="distType">The distance type</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuBruteForceMatcher.KnnMatch(Emgu.CV.GPU.GpuMat{System.Single},Emgu.CV.GPU.GpuMat{System.Single},Emgu.CV.GPU.GpuMat{System.Int32},Emgu.CV.GPU.GpuMat{System.Single},System.Int32,Emgu.CV.GPU.GpuMat{System.Byte})">
            <summary>
            For L1 and L2 distance type, find the k nearest neighbour using the brute force matcher. 
            </summary>
            <param name="queryDescriptors">The query descriptors</param>
            <param name="modelDescriptors">The model descriptors</param>
            <param name="modelIdx">The model index. A n x <paramref name="k"/> matrix where n = <paramref name="queryDescriptors"/>.Cols</param>
            <param name="distance">The matrix where the distance valus is stored. A n x <paramref name="k"/> matrix where n = <paramref name="queryDescriptors"/>.Size.Height</param>
            <param name="k">The number of nearest neighbours to be searched</param>
            <param name="mask">The mask</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuBruteForceMatcher.KnnMatch(Emgu.CV.GPU.GpuMat{System.Byte},Emgu.CV.GPU.GpuMat{System.Byte},Emgu.CV.GPU.GpuMat{System.Int32},Emgu.CV.GPU.GpuMat{System.Single},System.Int32,Emgu.CV.GPU.GpuMat{System.Byte})">
            <summary>
            For Hamming distance type, find the k nearest neighbour using the brute force matcher. 
            </summary>
            <param name="queryDescriptors">The query descriptors</param>
            <param name="modelDescriptors">The model descriptors</param>
            <param name="modelIdx">The model index. A n x <paramref name="k"/> matrix where n = <paramref name="queryDescriptors"/>.Cols</param>
            <param name="distance">The matrix where the distance valus is stored. A n x <paramref name="k"/> matrix where n = <paramref name="queryDescriptors"/>.Size.Height</param>
            <param name="k">The number of nearest neighbours to be searched</param>
            <param name="mask">The mask</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuBruteForceMatcher.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this matcher
            </summary>
        </member>
        <member name="T:Emgu.CV.GPU.GpuBruteForceMatcher.DistanceType">
            <summary>
            The distance type
            </summary>
        </member>
        <member name="F:Emgu.CV.GPU.GpuBruteForceMatcher.DistanceType.L1">
            <summary>
            Sum of absolute difference
            </summary>
        </member>
        <member name="F:Emgu.CV.GPU.GpuBruteForceMatcher.DistanceType.L2">
            <summary>
            Euclidean distance
            </summary>
        </member>
        <member name="F:Emgu.CV.GPU.GpuBruteForceMatcher.DistanceType.HammingDist">
            <summary>
            Hamming distance
            </summary>
        </member>
        <member name="T:Emgu.CV.GPU.GpuCascadeClassifier">
            <summary>
            Cascade Classifier for object detection using GPU
            </summary>
        </member>
        <member name="M:Emgu.CV.GPU.GpuCascadeClassifier.#ctor(System.String)">
            <summary>
            Create a GPU cascade classifier using the specific file
            </summary>
            <param name="fileName">The file to create the classifier from</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuCascadeClassifier.DetectMultiScale``1(Emgu.CV.GPU.GpuImage{``0,System.Byte},System.Double,System.Int32,System.Drawing.Size)">
            <summary>
            Finds rectangular regions in the given image that are likely to contain objects the cascade has been trained for and returns those regions as a sequence of rectangles.
            </summary>
            <param name="image">The image where search will take place</param>
            <param name="scaleFactor">The factor by which the search window is scaled between the subsequent scans, for example, 1.1 means increasing window by 10%. Use 1.2 for default.</param>
            <param name="minNeighbors">Minimum number (minus 1) of neighbor rectangles that makes up an object. All the groups of a smaller number of rectangles than min_neighbors-1 are rejected. If min_neighbors is 0, the function does not any grouping at all and returns all the detected candidate rectangles, which may be useful if the user wants to apply a customized grouping procedure. Use 4 for default.</param>
            <param name="minSize">Minimum window size. By default, it is set to the size of samples the classifier has been trained on (~20x20 for face detection). Use Size.Empty for default</param>
            <returns>An array of regions for the detected objects</returns>
        </member>
        <member name="M:Emgu.CV.GPU.GpuCascadeClassifier.DisposeObject">
            <summary>
            Release all unmanaged resources associated with this object
            </summary>
        </member>
        <member name="T:Emgu.CV.GPU.GpuDevice">
            <summary>
            The Gpu device information
            </summary>
        </member>
        <member name="M:Emgu.CV.GPU.GpuDevice.gpuDeviceInfoComputeCapability(System.IntPtr,System.Int32@,System.Int32@)">
            <summary>
            Get the compute capability of the device
            </summary>
            <param name="device">The device</param>
            <param name="major">The major version of the compute capability</param>
            <param name="minor">The minor version of the compute capability</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuDevice.gpuDeviceInfoMultiProcessorCount(System.IntPtr)">
            <summary>
            Get the number of multiprocessors on device
            </summary>
            <param name="device">The device</param>
            <returns>The number of multiprocessors on device</returns>
        </member>
        <member name="M:Emgu.CV.GPU.GpuDevice.gpuDeviceInfoDeviceName(System.IntPtr,System.Text.StringBuilder,System.Int32)">
            <summary>
            Get the device name
            </summary>
        </member>
        <member name="M:Emgu.CV.GPU.GpuDevice.#ctor">
            <summary>
            Query the information of the gpu device that is currently in use.
            </summary>
        </member>
        <member name="M:Emgu.CV.GPU.GpuDevice.#ctor(System.Int32)">
            <summary>
            Query the information of the gpu device with the specific id.
            </summary>
            <param name="deviceId">The device id</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuDevice.Supports(Emgu.CV.GPU.GpuDevice.GpuFeature)">
            <summary>
            Indicates if the decive has the specific feature
            </summary>
        </member>
        <member name="M:Emgu.CV.GPU.GpuDevice.DisposeObject">
            <summary>
            Release the unmanaged resource related to the GpuDevice
            </summary>
        </member>
        <member name="P:Emgu.CV.GPU.GpuDevice.ID">
            <summary>
            The id of the device
            </summary>
        </member>
        <member name="P:Emgu.CV.GPU.GpuDevice.Name">
            <summary>
            The name of the device
            </summary>
        </member>
        <member name="P:Emgu.CV.GPU.GpuDevice.CudaComputeCapability">
            <summary>
            The compute capability
            </summary>
        </member>
        <member name="P:Emgu.CV.GPU.GpuDevice.MultiProcessorCount">
            <summary>
            The number of single multi processors
            </summary>
        </member>
        <member name="P:Emgu.CV.GPU.GpuDevice.FreeMemory">
            <summary>
            Get the amount of free memory at the moment
            </summary>
        </member>
        <member name="P:Emgu.CV.GPU.GpuDevice.TotalMemory">
            <summary>
            Get the amount of total memory
            </summary>
        </member>
        <member name="T:Emgu.CV.GPU.GpuDevice.GpuFeature">
            <summary>
            GPU feature
            </summary>
        </member>
        <member name="F:Emgu.CV.GPU.GpuDevice.GpuFeature.Compute10">
            <summary>
            Cuda compute 1.0
            </summary>
        </member>
        <member name="F:Emgu.CV.GPU.GpuDevice.GpuFeature.Compute11">
            <summary>
            Cuda compute 1.1
            </summary>
        </member>
        <member name="F:Emgu.CV.GPU.GpuDevice.GpuFeature.Compute12">
            <summary>
            Cuda compute 1.2
            </summary>
        </member>
        <member name="F:Emgu.CV.GPU.GpuDevice.GpuFeature.Compute13">
            <summary>
            Cuda compute 1.3
            </summary>
        </member>
        <member name="F:Emgu.CV.GPU.GpuDevice.GpuFeature.Compute20">
            <summary>
            Cuda compute 2.0
            </summary>
        </member>
        <member name="F:Emgu.CV.GPU.GpuDevice.GpuFeature.Compute21">
            <summary>
            Cuda compute 2.1
            </summary>
        </member>
        <member name="F:Emgu.CV.GPU.GpuDevice.GpuFeature.NativeDouble">
            <summary>
            Native double
            </summary>
        </member>
        <member name="F:Emgu.CV.GPU.GpuDevice.GpuFeature.Atomics">
            <summary>
            Atomic
            </summary>
        </member>
        <member name="T:Emgu.CV.GPU.GpuDisparityBilateralFilter">
            <summary>
            Disparity map refinement using joint bilateral filtering given a single color image.
            Qingxiong Yang, Liang Wang†, Narendra Ahuja
            http://vision.ai.uiuc.edu/~qyang6/
            </summary>
        </member>
        <member name="M:Emgu.CV.GPU.GpuDisparityBilateralFilter.#ctor(System.Int32,System.Int32,System.Int32,System.Single,System.Single,System.Single)">
            <summary>
            Create a GpuDisparityBilateralFilter
            </summary>
            <param name="ndisp">Number of disparities. Use 64 as default</param>
            <param name="radius">Filter radius, use 3 as default</param>
            <param name="iters">Number of iterations, use 1 as default</param>
            <param name="edgeThreshold">Truncation of data continuity, use 0.1 as default</param>
            <param name="maxDiscThreshold">Truncation of disparity continuity, use 0.2 as default</param>
            <param name="sigmaRange">Filter range sigma, use 10.0 as default</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuDisparityBilateralFilter.Apply(Emgu.CV.GPU.GpuImage{Emgu.CV.Structure.Gray,System.Byte},Emgu.CV.GPU.GpuImage{Emgu.CV.Structure.Gray,System.Byte},Emgu.CV.GPU.GpuImage{Emgu.CV.Structure.Gray,System.Byte},Emgu.CV.GPU.Stream)">
            <summary>
            Apply the filter to the disparity image
            </summary>
            <param name="disparity">The input disparity map</param>
            <param name="image">The image</param>
            <param name="dst">The output disparity map, should have the same size as the input disparity map</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuDisparityBilateralFilter.DisposeObject">
            <summary>
            Release the unmanaged resources associated with the filter.
            </summary>
        </member>
        <member name="T:Emgu.CV.GPU.GpuHOGDescriptor">
            <summary>
            A HOG discriptor
            </summary>
        </member>
        <member name="M:Emgu.CV.GPU.GpuHOGDescriptor.#ctor">
            <summary>
            Create a new HOGDescriptor
            </summary>
        </member>
        <member name="M:Emgu.CV.GPU.GpuHOGDescriptor.#ctor(System.Drawing.Size,System.Drawing.Size,System.Drawing.Size,System.Drawing.Size,System.Int32,System.Double,System.Double,System.Boolean,System.Int32)">
            <summary>
            Create a new HOGDescriptor using the specific parameters
            </summary>
            <param name="blockSize">Block size in cells. Only (2,2) is supported for now.</param>
            <param name="cellSize">Cell size. Only (8, 8) is supported for now.</param>
            <param name="blockStride">Block stride. Must be a multiple of cell size.</param>
            <param name="gammaCorrection">Do gamma correction preprocessing or not.</param>
            <param name="L2HysThreshold">L2-Hys normalization method shrinkage.</param>
            <param name="nbins">Number of bins. Only 9 bins per cell is supported for now.</param>
            <param name="nLevels">Maximum number of detection window increases.</param>
            <param name="winSigma">Gaussian smoothing window parameter.</param>
            <param name="winSize">Detection window size. Must be aligned to block size and block stride.</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuHOGDescriptor.GetDefaultPeopleDetector">
            <summary>
            Returns coefficients of the classifier trained for people detection (for default window size).
            </summary>
            <returns>The default people detector</returns>
        </member>
        <member name="M:Emgu.CV.GPU.GpuHOGDescriptor.SetSVMDetector(System.Single[])">
            <summary>
            Set the SVM detector 
            </summary>
            <param name="detector">The SVM detector</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuHOGDescriptor.DetectMultiScale(Emgu.CV.GPU.GpuImage{Emgu.CV.Structure.Bgra,System.Byte},System.Double,System.Drawing.Size,System.Drawing.Size,System.Double,System.Int32)">
            <summary>
            Perfroms object detection with increasing detection window.
            </summary>
            <param name="image">The GpuImage to search in</param>
            <param name="hitThreshold">The threshold for the distance between features and classifying plane.</param>
            <param name="winStride">Window stride. Must be a multiple of block stride.</param>
            <param name="padding">Mock parameter to keep CPU interface compatibility. Must be (0,0).</param>
            <param name="scale">Coefficient of the detection window increase.</param>
            <param name="groupThreshold">After detection some objects could be covered by many rectangles. This coefficient regulates similarity threshold. 0 means don't perform grouping.</param>
            <returns>The regions where positives are found</returns>
        </member>
        <member name="M:Emgu.CV.GPU.GpuHOGDescriptor.DetectMultiScale(Emgu.CV.GPU.GpuImage{Emgu.CV.Structure.Gray,System.Byte},System.Double,System.Drawing.Size,System.Drawing.Size,System.Double,System.Int32)">
            <summary>
            Perfroms object detection with increasing detection window.
            </summary>
            <param name="image">The GpuImage to search in</param>
            <param name="hitThreshold">The threshold for the distance between features and classifying plane.</param>
            <param name="winStride">Window stride. Must be a multiple of block stride.</param>
            <param name="padding">Mock parameter to keep CPU interface compatibility. Must be (0,0).</param>
            <param name="scale">Coefficient of the detection window increase.</param>
            <param name="groupThreshold">After detection some objects could be covered by many rectangles. This coefficient regulates similarity threshold. 0 means don't perform grouping.</param>
            <returns>The regions where positives are found</returns>
        </member>
        <member name="M:Emgu.CV.GPU.GpuHOGDescriptor.DetectMultiScale(Emgu.CV.GPU.GpuImage{Emgu.CV.Structure.Bgra,System.Byte})">
            <summary>
            Perfroms object detection with increasing detection window.
            </summary>
            <param name="image">The GpuImage to search in</param>
            <returns>The regions where positives are found</returns>
        </member>
        <member name="M:Emgu.CV.GPU.GpuHOGDescriptor.DetectMultiScale(Emgu.CV.GPU.GpuImage{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            Perfroms object detection with increasing detection window.
            </summary>
            <param name="image">The GpuImage to search in</param>
            <returns>The regions where positives are found</returns>
        </member>
        <member name="M:Emgu.CV.GPU.GpuHOGDescriptor.ReleaseManagedResources">
            <summary>
            Release the managed resources associated with this object
            </summary>
        </member>
        <member name="M:Emgu.CV.GPU.GpuHOGDescriptor.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this HOGDescriptor
            </summary>
        </member>
        <member name="T:Emgu.CV.GPU.GpuImage`2">
            <summary>
            An GpuImage is very similar to the Emgu.CV.Image except that it is being used for GPU processing
            </summary>
            <typeparam name="TColor">Color type of this image (either Gray, Bgr, Bgra, Hsv, Hls, Lab, Luv, Xyz, Ycc, Rgb or Rbga)</typeparam>
            <typeparam name="TDepth">Depth of this image (either Byte, SByte, Single, double, UInt16, Int16 or Int32)</typeparam>
        </member>
        <member name="T:Emgu.CV.GPU.GpuMat`1">
            <summary>
            Similar to CvArray but use GPU for processing
            </summary>
            <typeparam name="TDepth">The type of element in the matrix</typeparam>
        </member>
        <member name="M:Emgu.CV.GPU.GpuMat`1.#ctor(System.IntPtr)">
            <summary>
            Create a GpuMat from the unmanaged pointer
            </summary>
            <param name="ptr">The unmanaged pointer to the GpuMat</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuMat`1.#ctor">
            <summary>
            Create an empty GpuMat
            </summary>
        </member>
        <member name="M:Emgu.CV.GPU.GpuMat`1.#ctor(System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Create a GpuMat of the specified size
            </summary>
            <param name="rows">The number of rows (height)</param>
            <param name="cols">The number of columns (width)</param>
            <param name="channels">The number of channels</param>
            <param name="continuous">Indicates if the data should be continuous</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuMat`1.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a GpuMat of the specified size
            </summary>
            <param name="rows">The number of rows (height)</param>
            <param name="cols">The number of columns (width)</param>
            <param name="channels">The number of channels</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuMat`1.#ctor(System.Drawing.Size,System.Int32)">
            <summary>
            Create a GpuMat of the specified size
            </summary>
            <param name="size">The size of the GpuMat</param>
            <param name="channels">The number of channels</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuMat`1.#ctor(Emgu.CV.GPU.GpuMat{`0},Emgu.CV.Structure.MCvSlice,Emgu.CV.Structure.MCvSlice)">
            <summary>
            Create a GpuMat from the specific region of <paramref name="mat"/>. The data is shared between the two GpuMat
            </summary>
            <param name="mat">The matrix where the region is extracted from</param>
            <param name="colRange">The column range. Use MCvSlice.WholeSeq for all columns.</param>
            <param name="rowRange">The row range. Use MCvSlice.WholeSeq for all rows.</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuMat`1.#ctor(Emgu.CV.CvArray{`0})">
            <summary>
            Create a GpuMat from an CvArray of the same depth type
            </summary>
            <param name="arr">The CvArry to be converted to GpuMat</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuMat`1.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this GpuMat
            </summary>
        </member>
        <member name="M:Emgu.CV.GPU.GpuMat`1.Upload(Emgu.CV.CvArray{`0})">
            <summary>
            Pefroms blocking upload data to GpuMat
            </summary>
            <param name="arr">The CvArray to be uploaded to GpuMat</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuMat`1.Download(Emgu.CV.CvArray{`0})">
            <summary>
            Downloads data from device to host memory. Blocking calls
            </summary>
            <param name="arr">The destination CvArray where the GpuMat data will be downloaded to.</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuMat`1.ToMatrix">
            <summary>
            Convert this GpuMat to a Matrix
            </summary>
            <returns>The matrix that contains the same values as this GpuMat</returns>
        </member>
        <member name="M:Emgu.CV.GPU.GpuMat`1.SplitInto(Emgu.CV.GPU.GpuMat{`0}[],Emgu.CV.GPU.Stream)">
            <summary> 
            Split current Image into an array of gray scale images where each element 
            in the array represent a single color channel of the original image
            </summary>
            <param name="gpuMats"> 
            An array of single channel GpuMat where each item
            in the array represent a single channel of the original GpuMat 
            </param>
             <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuMat`1.MergeFrom(Emgu.CV.GPU.GpuMat{`0}[],Emgu.CV.GPU.Stream)">
             <summary>
             Makes multi-channel array out of several single-channel arrays
             </summary>
            <param name="gpuMats"> 
            An array of single channel GpuMat where each item
            in the array represent a single channel of the GpuMat 
            </param>
             <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuMat`1.Split(Emgu.CV.GPU.Stream)">
            <summary> 
            Split current GpuMat into an array of single channel GpuMat where each element 
            in the array represent a single channel of the original GpuMat
            </summary>
             <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
            <returns> 
            An array of single channel GpuMat where each element  
            in the array represent a single channel of the original GpuMat 
            </returns>
        </member>
        <member name="M:Emgu.CV.GPU.GpuMat`1.MinMax(System.Double[]@,System.Double[]@,System.Drawing.Point[]@,System.Drawing.Point[]@)">
            <summary>
            Returns the min / max location and values for the image
            </summary>
            <param name="maxLocations">The maximum locations for each channel </param>
            <param name="maxValues">The maximum values for each channel</param>
            <param name="minLocations">The minimum locations for each channel</param>
            <param name="minValues">The minimum values for each channel</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuMat`1.Equals(Emgu.CV.GPU.GpuMat{`0})">
            <summary>
            Returns true if the two GpuMat equals
            </summary>
            <param name="other">The other GpuMat to be compares with</param>
            <returns>True if the two GpuMat equals</returns>
        </member>
        <member name="M:Emgu.CV.GPU.GpuMat`1.Convert``1(Emgu.CV.GPU.Stream)">
            <summary>
            Convert this GpuMat to different depth
            </summary>
            <typeparam name="TOtherDepth">The depth type to convert to</typeparam>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
            <returns>GpuMat of different depth</returns>
        </member>
        <member name="M:Emgu.CV.GPU.GpuMat`1.Reshape(System.Int32,System.Int32)">
            <summary>
            Changes shape of GpuMat without copying data.
            </summary>
            <param name="newCn">New number of channels. newCn = 0 means that the number of channels remains unchanged.</param>
            <param name="newRows">New number of rows. newRows = 0 means that the number of rows remains unchanged unless it needs to be changed according to newCn value.</param>
            <returns>A GpuMat of different shape</returns>
        </member>
        <member name="M:Emgu.CV.GPU.GpuMat`1.SetTo(Emgu.CV.Structure.MCvScalar,Emgu.CV.GPU.GpuMat{System.Byte},Emgu.CV.GPU.Stream)">
            <summary>
            Copies scalar value to every selected element of the destination GpuMat:
            GpuMat(I)=value if mask(I)!=0
            </summary>
            <param name="value">Fill value</param>
            <param name="mask">Operation mask, 8-bit single channel GpuMat; specifies elements of destination array to be changed. Can be null if not used.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuMat`1.GetSubRect(System.Drawing.Rectangle)">
            <summary>
            Returns a GpuMat corresponding to a specified rectangle of the current GpuMat. The data is shared with the current matrix. In other words, it allows the user to treat a rectangular part of input array as a stand-alone array.
            </summary>
            <param name="region">Zero-based coordinates of the rectangle of interest.</param>
            <returns>A GpuMat that represent the region of the current matrix.</returns>
            <remarks>The parent GpuMat should never be released before the returned GpuMat the represent the subregion</remarks>
        </member>
        <member name="M:Emgu.CV.GPU.GpuMat`1.Row(System.Int32)">
            <summary>
            Returns a GpuMat corresponding to the ith row of the GpuMat. The data is shared with the current GpuMat. 
            </summary>
            <param name="i">The row to be extracted</param>
            <returns>The ith row of the GpuMat</returns>
            <remarks>The parent GpuMat should never be released before the returned GpuMat that represent the subregion</remarks>
        </member>
        <member name="M:Emgu.CV.GPU.GpuMat`1.RowRange(System.Int32,System.Int32)">
            <summary>
            Returns a GpuMat corresponding to the [<paramref name="start"/> <paramref name="end"/>) rows of the GpuMat. The data is shared with the current GpuMat. 
            </summary>
            <param name="start">The inclusive stating row to be extracted</param>
            <param name="end">The exclusive ending row to be extracted</param>
            <returns>The [<paramref name="start"/> <paramref name="end"/>) rows of the GpuMat</returns>
            <remarks>The parent GpuMat should never be released before the returned GpuMat that represent the subregion</remarks>
        </member>
        <member name="M:Emgu.CV.GPU.GpuMat`1.Col(System.Int32)">
            <summary>
            Returns a GpuMat corresponding to the ith column of the GpuMat. The data is shared with the current GpuMat. 
            </summary>
            <param name="i">The column to be extracted</param>
            <returns>The ith column of the GpuMat</returns>
            <remarks>The parent GpuMat should never be released before the returned GpuMat that represent the subregion</remarks>
        </member>
        <member name="M:Emgu.CV.GPU.GpuMat`1.ColRange(System.Int32,System.Int32)">
            <summary>
            Returns a GpuMat corresponding to the [<paramref name="start"/> <paramref name="end"/>) columns of the GpuMat. The data is shared with the current GpuMat. 
            </summary>
            <param name="start">The inclusive stating column to be extracted</param>
            <param name="end">The exclusive ending column to be extracted</param>
            <returns>The [<paramref name="start"/> <paramref name="end"/>) columns of the GpuMat</returns>
            <remarks>The parent GpuMat should never be released before the returned GpuMat that represent the subregion</remarks>
        </member>
        <member name="P:Emgu.CV.GPU.GpuMat`1.Size">
            <summary>
            Get the GpuMat size:
            width == number of columns, height == number of rows
            </summary>
        </member>
        <member name="P:Emgu.CV.GPU.GpuMat`1.NumberOfChannels">
            <summary>
            Get the number of channels in the GpuMat
            </summary>
        </member>
        <member name="P:Emgu.CV.GPU.GpuMat`1.IsEmpty">
            <summary>
            Check if the GpuMat is Empty
            </summary>
        </member>
        <member name="P:Emgu.CV.GPU.GpuMat`1.IsContinuous">
            <summary>
            Check if the GpuMat is Continuous
            </summary>
        </member>
        <member name="M:Emgu.CV.GPU.GpuImage`2.#ctor(System.IntPtr)">
            <summary>
            Create the GpuImage from the unmanaged pointer.
            </summary>
            <param name="ptr">The unmanaged pointer to the GpuMat. It is the user's responsibility that the Color type and depth matches between the managed class and unmanaged pointer.</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuImage`2.#ctor(Emgu.CV.Image{`0,`1})">
            <summary>
            Create a GPU image from a regular image
            </summary>
            <param name="img">The image to be converted to GPU image</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuImage`2.#ctor(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Create a GpuImage of the specific size
            </summary>
            <param name="rows">The number of rows (height)</param>
            <param name="cols">The number of columns (width)</param>
            <param name="continuous">Indicates if the data should be continuous</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuImage`2.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a GpuImage of the specific size
            </summary>
            <param name="rows">The number of rows (height)</param>
            <param name="cols">The number of columns (width)</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuImage`2.#ctor(System.Drawing.Size)">
            <summary>
            Create a GpuImage of the specific size
            </summary>
            <param name="size">The size of the image</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuImage`2.#ctor(Emgu.CV.GPU.GpuImage{`0,`1},Emgu.CV.Structure.MCvSlice,Emgu.CV.Structure.MCvSlice)">
            <summary>
            Create a GpuImage from the specific region of <paramref name="image"/>. The data is shared between the two GpuImage
            </summary>
            <param name="image">The GpuImage where the region is extracted from</param>
            <param name="colRange">The column range. Use MCvSlice.WholeSeq for all columns.</param>
            <param name="rowRange">The row range. Use MCvSlice.WholeSeq for all rows.</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuImage`2.ToImage">
            <summary>
            Convert the current GpuImage to a regular Image.
            </summary>
            <returns>A regular image</returns>
        </member>
        <member name="M:Emgu.CV.GPU.GpuImage`2.Convert``2">
            <summary> Convert the current GpuImage to the specific color and depth </summary>
            <typeparam name="TOtherColor"> The type of color to be converted to </typeparam>
            <typeparam name="TOtherDepth"> The type of pixel depth to be converted to </typeparam>
            <returns>GpuImage of the specific color and depth </returns>
        </member>
        <member name="M:Emgu.CV.GPU.GpuImage`2.ConvertFrom``2(Emgu.CV.GPU.GpuImage{``0,``1})">
            <summary>
            Convert the source image to the current image, if the size are different, the current image will be a resized version of the srcImage. 
            </summary>
            <typeparam name="TSrcColor">The color type of the source image</typeparam>
            <typeparam name="TSrcDepth">The color depth of the source image</typeparam>
            <param name="srcImage">The sourceImage</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuImage`2.Clone">
            <summary>
            Create a clone of this GpuImage
            </summary>
            <returns>A clone of this GpuImage</returns>
        </member>
        <member name="M:Emgu.CV.GPU.GpuImage`2.Split(Emgu.CV.GPU.Stream)">
            <summary> 
            Split current Image into an array of gray scale images where each element 
            in the array represent a single color channel of the original image
            </summary>
             <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
            <returns> 
            An array of gray scale images where each element  
            in the array represent a single color channel of the original image 
            </returns>
        </member>
        <member name="M:Emgu.CV.GPU.GpuImage`2.Resize(System.Drawing.Size,Emgu.CV.CvEnum.INTER,Emgu.CV.GPU.Stream)">
            <summary>
            Resize the GpuImage. The calling GpuMat be GpuMat%lt;Byte&gt;. If steam is specified, it has to be either 1 or 4 channels.
            </summary>
            <param name="size">The new size</param>
            <param name="interpolationType">The interpolation type</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
            <returns>A GpuImage of the new size</returns>
        </member>
        <member name="M:Emgu.CV.GPU.GpuImage`2.Convolution(Emgu.CV.ConvolutionKernelF,Emgu.CV.GPU.Stream)">
            <summary> 
            Performs a convolution using the specific <paramref name="kernel"/> 
            </summary>
            <param name="kernel">The convolution kernel</param>
             <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
            <returns>The result of the convolution</returns>
        </member>
        <member name="M:Emgu.CV.GPU.GpuImage`2.GetSubRect(System.Drawing.Rectangle)">
            <summary>
            Returns a GpuImage corresponding to a specified rectangle of the current GpuImage. The data is shared with the current matrix. In other words, it allows the user to treat a rectangular part of input array as a stand-alone array.
            </summary>
            <param name="region">Zero-based coordinates of the rectangle of interest.</param>
            <returns>A GpuImage that represent the region of the current GpuImage.</returns>
            <remarks>The parent GpuImage should never be released before the returned GpuImage that represent the subregion</remarks>
        </member>
        <member name="M:Emgu.CV.GPU.GpuImage`2.Row(System.Int32)">
            <summary>
            Returns a GpuImage corresponding to the ith row of the GpuImage. The data is shared with the current Image. 
            </summary>
            <param name="i">The row to be extracted</param>
            <returns>The ith row of the GpuImage</returns>
            <remarks>The parent GpuImage should never be released before the returned GpuImage that represent the subregion</remarks>
        </member>
        <member name="M:Emgu.CV.GPU.GpuImage`2.RowRange(System.Int32,System.Int32)">
            <summary>
            Returns a GpuImage corresponding to the [<paramref name="start"/> <paramref name="end"/>) rows of the GpuImage. The data is shared with the current Image. 
            </summary>
            <param name="start">The inclusive stating row to be extracted</param>
            <param name="end">The exclusive ending row to be extracted</param>
            <returns>The [<paramref name="start"/> <paramref name="end"/>) rows of the GpuImage</returns>
            <remarks>The parent GpuImage should never be released before the returned GpuImage that represent the subregion</remarks>
        </member>
        <member name="M:Emgu.CV.GPU.GpuImage`2.Col(System.Int32)">
            <summary>
            Returns a GpuImage corresponding to the ith column of the GpuImage. The data is shared with the current Image. 
            </summary>
            <param name="i">The column to be extracted</param>
            <returns>The ith column of the GpuImage</returns>
            <remarks>The parent GpuImage should never be released before the returned GpuImage that represent the subregion</remarks>
        </member>
        <member name="M:Emgu.CV.GPU.GpuImage`2.ColRange(System.Int32,System.Int32)">
            <summary>
            Returns a GpuImage corresponding to the [<paramref name="start"/> <paramref name="end"/>) columns of the GpuImage. The data is shared with the current Image. 
            </summary>
            <param name="start">The inclusive stating column to be extracted</param>
            <param name="end">The exclusive ending column to be extracted</param>
            <returns>The [<paramref name="start"/> <paramref name="end"/>) columns of the GpuImage</returns>
            <remarks>The parent GpuImage should never be released before the returned GpuImage that represent the subregion</remarks>
        </member>
        <member name="M:Emgu.CV.GPU.GpuImage`2.Save(System.String)">
            <summary>
            Saving the GPU image to file
            </summary>
            <param name="fileName">The file to be saved to</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuImage`2.Emgu#CV#IImage#get_Ptr">
            <summary>
            An GpuImage is very similar to the Emgu.CV.Image except that it is being used for GPU processing
            </summary>
            <typeparam name="TColor">Color type of this image (either Gray, Bgr, Bgra, Hsv, Hls, Lab, Luv, Xyz, Ycc, Rgb or Rbga)</typeparam>
            <typeparam name="TDepth">Depth of this image (either Byte, SByte, Single, double, UInt16, Int16 or Int32)</typeparam>
        </member>
        <member name="P:Emgu.CV.GPU.GpuImage`2.Bitmap">
            <summary>
            convert the current GpuImage to its equavalent Bitmap representation
            </summary>
        </member>
        <member name="T:Emgu.CV.GPU.GpuInvoke">
            <summary>
            This class wraps the functional calls to the opencv_gpu module
            </summary>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.GetCudaEnabledDeviceCount">
            <summary>
            Get the number of Cuda enabled devices
            </summary>
            <returns>The number of Cuda enabled devices</returns>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.GetDevice">
            <summary>
            Get the current Cuda device id
            </summary>
            <returns>The current Cuda device id</returns>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.GpuMatCreateDefault">
            <summary>
            Create an empty GpuMat 
            </summary>
            <returns>Pointer to an empty GpuMat</returns>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.GpuMatCreate(System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a GpuMat of the specified size
            </summary>
            <param name="rows">The number of rows (height)</param>
            <param name="cols">The number of columns (width)</param>
            <param name="type">The type of GpuMat</param>
            <returns>Pointer to the GpuMat</returns>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.GpuMatCreateContinuous(System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a GpuMat of the specified size. The allocated data is continuous within this GpuMat.
            </summary>
            <param name="rows">The number of rows (height)</param>
            <param name="cols">The number of columns (width)</param>
            <param name="type">The type of GpuMat</param>
            <returns>Pointer to the GpuMat</returns>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.GpuMatIsContinuous(System.IntPtr)">
            <summary>
            Returns true iff the GpuMatrix data is continuous
            (i.e. when there are no gaps between successive rows).
            </summary>
            <param name="gpuMat">The GpuMat to be checked</param>
            <returns>True if the GpuMat is continuous</returns>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.GpuMatGetRegion(System.IntPtr,Emgu.CV.Structure.MCvSlice,Emgu.CV.Structure.MCvSlice)">
            <summary>
            Create a GpuMat from the specific region of <paramref name="gpuMat"/>. The data is shared between the two GpuMat.
            </summary>
            <param name="gpuMat">The gpuMat to extract regions from.</param>
            <param name="colRange">The column range. Use MCvSlice.WholeSeq for all columns.</param>
            <param name="rowRange">The row range. Use MCvSlice.WholeSeq for all rows.</param>
            <returns>Pointer to the GpuMat</returns>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.GpuMatIsEmpty(System.IntPtr)">
            <summary>
            Check if the GpuMat is empty
            </summary>
            <param name="gpuMat">The GpuMat</param>
            <returns>True if the GpuMat is empty</returns>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.GpuMatSetTo(System.IntPtr,Emgu.CV.Structure.MCvScalar,System.IntPtr,System.IntPtr)">
            <summary>
            Copies scalar value to every selected element of the destination GpuMat:
            arr(I)=value if mask(I)!=0
            </summary>
            <param name="mat">The destination GpuMat</param>
            <param name="value">Fill value</param>
            <param name="mask">Operation mask, 8-bit single channel GpuMat; specifies elements of destination GpuMat to be changed. Can be IntPtr.Zero if not used</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>     
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.GpuMatRelease(System.IntPtr@)">
            <summary>
            Release the GpuMat
            </summary>
            <param name="mat">Pointer to the GpuMat</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.GpuMatCreateFromArr(System.IntPtr)">
            <summary>
            Convert a CvArr to a GpuMat
            </summary>
            <param name="arr">Pointer to a CvArr</param>
            <returns>Pointer to the GpuMat</returns>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.GpuMatGetSize(System.IntPtr)">
            <summary>
            Get the GpuMat size:
            width == number of columns, height == number of rows
            </summary>
            <param name="gpuMat">The GpuMat</param>
            <returns>The size of the matrix</returns>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.GpuMatGetChannels(System.IntPtr)">
            <summary>
            Get the number of channels in the GpuMat
            </summary>
            <param name="gpuMat">The GpuMat</param>
            <returns>The number of channels in the GpuMat</returns>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.GpuMatUpload(System.IntPtr,System.IntPtr)">
            <summary>
            Pefroms blocking upload data to GpuMat.
            </summary>
            <param name="gpuMat">The destination gpuMat</param>
            <param name="arr">The CvArray to be uploaded to GPU</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.GpuMatDownload(System.IntPtr,System.IntPtr)">
            <summary>
            Downloads data from device to host memory. Blocking calls.
            </summary>
            <param name="gpuMat">The source GpuMat</param>
            <param name="arr">The CvArray where data will be downloaded to</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.CvtColor(System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.COLOR_CONVERSION,System.IntPtr)">
            <summary>
            Converts image from one color space to another
            </summary>
            <param name="src">The source GpuMat</param>
            <param name="dst">The destination GpuMat</param>
            <param name="code">The color conversion code</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.Copy(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Copy the source GpuMat to destination GpuMat, using an optional mask.
            </summary>
            <param name="src">The GpuMat to be copied from</param>
            <param name="dst">The GpuMat to be copied to</param>
            <param name="mask">The optional mask, use IntPtr.Zero if not needed.</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.GetSubRect(System.IntPtr,System.Drawing.Rectangle)">
            <summary>
            Returns header, corresponding to a specified rectangle of the input GpuMat. In other words, it allows the user to treat a rectangular part of input array as a stand-alone array.
            </summary>
            <param name="mat">Input GpuMat</param>
            <param name="rect">Zero-based coordinates of the rectangle of interest.</param>
            <returns>Pointer to the resultant sub-array header.</returns>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.Add(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Adds one matrix to another (c = a + b).
            Supports CV_8UC1, CV_8UC4, CV_32SC1, CV_32FC1 types.
            </summary>
            <param name="a">The first matrix to be added.</param>
            <param name="b">The second matrix to be added.</param>
            <param name="c">The sum of the two matrix</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.Add(System.IntPtr,Emgu.CV.Structure.MCvScalar,System.IntPtr,System.IntPtr)">
            <summary>
            Adds scalar to a matrix (c = a + scalar)
            Supports CV_32FC1 and CV_32FC2 type
            </summary>
            <param name="a">The matrix to be added.</param>
            <param name="scalar">The scalar to be added.</param>
            <param name="c">The sum of the matrix and the scalar</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.Subtract(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Subtracts one matrix from another (c = a - b).
            Supports CV_8UC1, CV_8UC4, CV_32SC1, CV_32FC1 types
            </summary>
            <param name="a">The matrix where subtraction take place</param>
            <param name="b">The matrix to be substracted</param>
            <param name="c">The result of a - b</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.Subtract(System.IntPtr,Emgu.CV.Structure.MCvScalar,System.IntPtr,System.IntPtr)">
            <summary>
            Subtracts one matrix from another (c = a - scalar).
            Supports CV_32FC1 and CV_32FC2 type.
            </summary>
            <param name="a">The matrix to be substraced from</param>
            <param name="scalar">The scalar to be substracted</param>
            <param name="c">The matrix substraced by the scalar</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.Multiply(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Computes element-wise product of the two GpuMat (c = a * b).
            Supports CV_8UC1, CV_8UC4, CV_32SC1, CV_32FC1 types.
            </summary>
            <param name="a">The first GpuMat to be element-wise multiplied.</param>
            <param name="b">The second GpuMat to be element-wise multiplied.</param>
            <param name="c">The element-wise multiplication of the two GpuMat</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.Multiply(System.IntPtr,Emgu.CV.Structure.MCvScalar,System.IntPtr,System.IntPtr)">
            <summary>
            Multiplies GpuMat to a scalar (c = a * scalar).
            Supports CV_32FC1 and CV_32FC2 type.
            </summary>
            <param name="a">The first GpuMat to be element-wise multiplied.</param>
            <param name="scalar">The scalar to be multiplied</param>
            <param name="c">The result of the GpuMat mutiplied by the scalar</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.Divide(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Computes element-wise quotient of the two GpuMat (c = a / b).
            Supports CV_8UC1, CV_8UC4, CV_32SC1, CV_32FC1 types.
            </summary>
            <param name="a">The first GpuMat</param>
            <param name="b">The second GpuMat</param>
            <param name="c">The element-wise quotient of the two GpuMat</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.Divide(System.IntPtr,Emgu.CV.Structure.MCvScalar,System.IntPtr,System.IntPtr)">
            <summary>
            computes element-wise quotient of a GpuMat and scalar (c = a / scalar).
            Supports CV_32FC1 and CV_32FC2 type.
            </summary>
            <param name="a">The first GpuMat to be element-wise divided.</param>
            <param name="scalar">The scalar to be divided</param>
            <param name="c">The result of the GpuMat divided by the scalar</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.Absdiff(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Computes element-wise absolute difference of two GpuMats (c = abs(a - b)).
            Supports CV_8UC1, CV_8UC4, CV_32SC1, CV_32FC1 types.
            </summary>
            <param name="a">The first GpuMat</param>
            <param name="b">The second GpuMat</param>
            <param name="c">The result of the element-wise absolute difference.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.Absdiff(System.IntPtr,Emgu.CV.Structure.MCvScalar,System.IntPtr,System.IntPtr)">
            <summary>
            Computes element-wise absolute difference of GpuMat and scalar (c = abs(a - s)).
            Supports only CV_32FC1 type.
            </summary>
            <param name="a">A GpuMat</param>
            <param name="scalar">A scalar</param>
            <param name="c">The result of the element-wise absolute difference.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.Compare(System.IntPtr,System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.CMP_TYPE,System.IntPtr)">
            <summary>
            Compares elements of two GpuMats (c = a &lt;cmpop&gt; b).
            Supports CV_8UC4, CV_32FC1 types
            </summary>
            <param name="a">The first GpuMat</param>
            <param name="b">The second GpuMat</param>
            <param name="c">The result of the comparison.</param>
            <param name="cmpop">The type of comparison</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.LUT(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Transforms 8-bit unsigned integers using lookup table: dst(i)=lut(src(i)).
            Destination GpuMat will have the depth type as lut and the same channels number as source.
            Supports CV_8UC1, CV_8UC3 types.
            </summary>
            <param name="src">The source GpuMat</param>
            <param name="lut">Pointer to a CvArr (e.g. Emgu.CV.Matrix).</param>
            <param name="dst">The destination GpuMat</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.Resize(System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.INTER,System.IntPtr)">
            <summary>
            Resizes the image.
            </summary>
            <param name="src">The source image. Has to be GpuMat&lt;Byte&gt;. If stream is used, the GpuMat has to be either single channel or 4 channels.</param>
            <param name="dst">The destination image.</param>
            <param name="interpolation">The interpolation type. Supports INTER_NEAREST, INTER_LINEAR.</param>
            <param name="stream">Use a stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.Reshape(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Changes shape of GpuMat without copying data.
            </summary>
            <param name="src">The GpuMat to be reshaped.</param>
            <param name="newCn">New number of channels. newCn = 0 means that the number of channels remains unchanged.</param>
            <param name="newRows">New number of rows. newRows = 0 means that the number of rows remains unchanged unless it needs to be changed according to newCn value.</param>
            <returns>A GpuMat of different shape</returns>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.Split(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Copies each plane of a multi-channel GpuMat to a dedicated GpuMat
            </summary>
            <param name="src">The multi-channel gpuMat</param>
            <param name="dstArray">Pointer to an array of single channel GpuMat pointers</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.Merge(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Makes multi-channel GpuMat out of several single-channel GpuMats
            </summary>
            <param name="srcArr">Pointer to an array of single channel GpuMat pointers</param>
            <param name="dst">The multi-channel gpuMat</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.Exp(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Computes exponent of each matrix element (b = exp(a))
            </summary>
            <param name="src">The source GpuMat. Supports only CV_32FC1 type</param>
            <param name="dst">The resulting GpuMat</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.Log(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Computes natural logarithm of absolute value of each matrix element: b = log(abs(a))
            </summary>
            <param name="src">The source GpuMat. Supports only CV_32FC1 type</param>
            <param name="dst">The resulting GpuMat</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.Magnitude(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Computes magnitude of each (x(i), y(i)) vector
            </summary>
            <param name="x">The source GpuMat. Supports only floating-point type</param>
            <param name="y">The source GpuMat. Supports only floating-point type</param>
            <param name="magnitude">The destination GpuMat. Supports only floating-point type</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.MagnitudeSqr(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Computes squared magnitude of each (x(i), y(i)) vector
            </summary>
            <param name="x">The source GpuMat. Supports only floating-point type</param>
            <param name="y">The source GpuMat. Supports only floating-point type</param>
            <param name="magnitude">The destination GpuMat. Supports only floating-point type</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.Phase(System.IntPtr,System.IntPtr,System.IntPtr,System.Boolean,System.IntPtr)">
            <summary>
            Computes angle (angle(i)) of each (x(i), y(i)) vector
            </summary>
            <param name="x">The source GpuMat. Supports only floating-point type</param>
            <param name="y">The source GpuMat. Supports only floating-point type</param>
            <param name="angle">The destination GpuMat. Supports only floating-point type</param>
            <param name="angleInDegrees">If true, the output angle is in degrees, otherwise in radian</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.CartToPolar(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.Boolean,System.IntPtr)">
            <summary>
            Converts Cartesian coordinates to polar
            </summary>
            <param name="x">The source GpuMat. Supports only floating-point type</param>
            <param name="y">The source GpuMat. Supports only floating-point type</param>
            <param name="magnitude">The destination GpuMat. Supports only floating-point type</param>
            <param name="angle">The destination GpuMat. Supports only floating-point type</param>
            <param name="angleInDegrees">If true, the output angle is in degrees, otherwise in radian</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.PolarToCart(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.Boolean,System.IntPtr)">
            <summary>
            Converts polar coordinates to Cartesian
            </summary>
            <param name="magnitude">The source GpuMat. Supports only floating-point type</param>
            <param name="angle">The source GpuMat. Supports only floating-point type</param>
            <param name="x">The destination GpuMat. Supports only floating-point type</param>
            <param name="y">The destination GpuMat. Supports only floating-point type</param>
            <param name="angleInDegrees">If true, the input angle is in degrees, otherwise in radian</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.ConvertTo(System.IntPtr,System.IntPtr,System.Double,System.Double,System.IntPtr)">
            <summary>
            This function has several different purposes and thus has several synonyms. It copies one GpuMat to another with optional scaling, which is performed first, and/or optional type conversion, performed after:
            dst(I)=src(I)*scale + (shift,shift,...)
            All the channels of multi-channel GpuMats are processed independently.
            The type conversion is done with rounding and saturation, that is if a result of scaling + conversion can not be represented exactly by a value of destination GpuMat element type, it is set to the nearest representable value on the real axis.
            In case of scale=1, shift=0 no prescaling is done. This is a specially optimized case and it has the appropriate convertTo synonym.
            </summary>
            <param name="src">Source GpuMat</param>
            <param name="dst">Destination GpuMat</param>
            <param name="scale">Scale factor</param>
            <param name="shift">Value added to the scaled source GpuMat elements</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>      
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.MinMaxLoc(System.IntPtr,System.Double@,System.Double@,System.Drawing.Point@,System.Drawing.Point@,System.IntPtr)">
            <summary>
            Finds minimum and maximum element values and their positions. The extremums are searched over the whole GpuMat or, if mask is not IntPtr.Zero, in the specified GpuMat region.
            </summary>
            <param name="gpuMat">The source GpuMat, single-channel</param>
            <param name="minVal">Pointer to returned minimum value</param>
            <param name="maxVal">Pointer to returned maximum value</param>
            <param name="minLoc">Pointer to returned minimum location</param>
            <param name="maxLoc">Pointer to returned maximum location</param>
            <param name="mask">The optional mask that is used to select a subarray. Use IntPtr.Zero if not needed</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.MatchTemplate(System.IntPtr,System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.TM_TYPE)">
            <summary>
            This function is similiar to cvCalcBackProjectPatch. It slids through image, compares overlapped patches of size wxh with templ using the specified method and stores the comparison results to result
            </summary>
            <param name="image">Image where the search is running. It should be 8-bit or 32-bit floating-point</param>
            <param name="templ">Searched template; must be not greater than the source image and the same data type as the image</param>
            <param name="result">A map of comparison results; single-channel 32-bit floating-point. If image is WxH and templ is wxh then result must be W-w+1xH-h+1.</param>
            <param name="method">Specifies the way the template must be compared with image regions </param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.MeanStdDev(System.IntPtr,Emgu.CV.Structure.MCvScalar@,Emgu.CV.Structure.MCvScalar@)">
            <summary>
            Computes mean value and standard deviation
            </summary>
            <param name="mtx">The GpuMat. Supports only CV_8UC1 type</param>
            <param name="mean">The mean value</param>
            <param name="stddev">The standard deviation</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.Norm(System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.NORM_TYPE)">
            <summary>
            Computes norm of the difference between two GpuMats
            </summary>
            <param name="src1">The GpuMat. Supports only CV_8UC1 type</param>
            <param name="src2">If IntPtr.Zero, norm operation is apply to <paramref name="src1"/> only. Otherwise, this is the GpuMat of type CV_8UC1</param>
            <param name="normType">The norm type. Supports NORM_INF, NORM_L1, NORM_L2.</param>
            <returns>The norm of the <paramref name="src1"/> if <paramref name="src2"/> is IntPtr.Zero. Otherwise the norm of the difference between two GpuMats.</returns>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.CountNonZero(System.IntPtr)">
            <summary>
            Counts non-zero array elements
            </summary>
            <param name="src">The GpuMat</param>
            <returns>The number of non-zero GpuMat elements</returns>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.gpuMatFlip(System.IntPtr,System.IntPtr,System.Int32,System.IntPtr)">
             <summary>
             Flips the GpuMat in one of different 3 ways (row and column indices are 0-based):
             dst(i,j)=src(rows(src)-i-1,j) if flip_mode = 0
             dst(i,j)=src(i,cols(src1)-j-1) if flip_mode &gt; 0
             dst(i,j)=src(rows(src)-i-1,cols(src)-j-1) if flip_mode &lt; 0
             </summary>
             <param name="src">Source GpuMat.</param>
             <param name="dst">Destination GpuMat.</param>
             <param name="flipMode">
             Specifies how to flip the GpuMat.
             flip_mode = 0 means flipping around x-axis, 
             flip_mode &gt; 0 (e.g. 1) means flipping around y-axis and 
             flip_mode &lt; 0 (e.g. -1) means flipping around both axises. 
            </param>
             <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>      
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.Flip(System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.FLIP,Emgu.CV.GPU.Stream)">
            <summary>
            Flips the GpuMat&lt;Byte&gt; in one of different 3 ways (row and column indices are 0-based). 
            </summary>
            <param name="src">The source GpuMat&lt;Byte&gt;. If stream is used, the GpuMat has to be either single channel or 4 channels.</param>
            <param name="dst">Destination GpuMat. The same source and type as <paramref name="src"/></param>
            <param name="flipType">Specifies how to flip the GpuMat.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>      
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.Erode(System.IntPtr,System.IntPtr,System.IntPtr,System.Drawing.Point,System.Int32,System.IntPtr)">
            <summary>
            Erodes the image (applies the local minimum operator).
            Supports CV_8UC1, CV_8UC4 type.
            </summary>
            <param name="src">The source GpuMat</param>
            <param name="dst">The destination GpuMat</param>
            <param name="kernel">The morphology kernel, pointer to an CvArr. If it is IntPtr.Zero, a 3x3 rectangular structuring element is used.</param>
            <param name="anchor">The center of the kernel. User (-1, -1) for the default kernel center.</param>
            <param name="iterations">The number of iterations morphology is applied</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.Dilate(System.IntPtr,System.IntPtr,System.IntPtr,System.Drawing.Point,System.Int32,System.IntPtr)">
            <summary>
            Dilate the image (applies the local maximum operator).
            Supports CV_8UC1, CV_8UC4 type.
            </summary>
            <param name="src">The source GpuMat</param>
            <param name="dst">The destination GpuMat</param>
            <param name="kernel">The morphology kernel, pointer to an CvArr. If it is IntPtr.Zero, a 3x3 rectangular structuring element is used.</param>
            <param name="anchor">The center of the kernel. User (-1, -1) for the default kernel center.</param>
            <param name="iterations">The number of iterations morphology is applied</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.BitwiseXor(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Calculates per-element bit-wise logical conjunction of two GpuMats:
            dst(I)=src1(I)^src2(I) if mask(I)!=0
            In the case of floating-point GpuMats their bit representations are used for the operation. All the GpuMats must have the same type, except the mask, and the same size
            </summary>
            <param name="src1">The first source GpuMat</param>
            <param name="src2">The second source GpuMat</param>
            <param name="dst">The destination GpuMat</param>
            <param name="mask">Mask, 8-bit single channel GpuMat; specifies elements of destination GpuMat to be changed. Use IntPtr.Zero if not needed.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.BitwiseOr(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Calculates per-element bit-wise logical or of two GpuMats:
            dst(I)=src1(I) | src2(I) if mask(I)!=0
            In the case of floating-point GpuMats their bit representations are used for the operation. All the GpuMats must have the same type, except the mask, and the same size
            </summary>
            <param name="src1">The first source GpuMat</param>
            <param name="src2">The second source GpuMat</param>
            <param name="dst">The destination GpuMat</param>
            <param name="mask">Mask, 8-bit single channel GpuMat; specifies elements of destination GpuMat to be changed. Use IntPtr.Zero if not needed.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.BitwiseAnd(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Calculates per-element bit-wise logical and of two GpuMats:
            dst(I)=src1(I) &amp; src2(I) if mask(I)!=0
            In the case of floating-point GpuMats their bit representations are used for the operation. All the GpuMats must have the same type, except the mask, and the same size
            </summary>
            <param name="src1">The first source GpuMat</param>
            <param name="src2">The second source GpuMat</param>
            <param name="dst">The destination GpuMat</param>
            <param name="mask">Mask, 8-bit single channel GpuMat; specifies elements of destination GpuMat to be changed. Use IntPtr.Zero if not needed.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.BitwiseNot(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Calculates per-element bit-wise logical not
            dst(I)=~src(I) if mask(I)!=0
            In the case of floating-point GpuMats their bit representations are used for the operation. All the GpuMats must have the same type, except the mask, and the same size
            </summary>
            <param name="src">The source GpuMat</param>
            <param name="dst">The destination GpuMat</param>
            <param name="mask">Mask, 8-bit single channel GpuMat; specifies elements of destination GpuMat to be changed. Use IntPtr.Zero if not needed.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.Min(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Computes per-element minimum of two GpuMats (dst = min(src1, src2))
            </summary>
            <param name="src1">The first GpuMat</param>
            <param name="src2">The second GpuMat</param>
            <param name="dst">The result GpuMat</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.Min(System.IntPtr,System.Double,System.IntPtr,System.IntPtr)">
            <summary>
            Computes per-element minimum of GpuMat and scalar (dst = min(src1, src2))
            </summary>
            <param name="src1">The first GpuMat</param>
            <param name="src2">The scalar</param>
            <param name="dst">The result GpuMat</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.Max(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Computes per-element maximum of two GpuMats (dst = max(src1, src2))
            </summary>
            <param name="src1">The first GpuMat</param>
            <param name="src2">The second GpuMat</param>
            <param name="dst">The result GpuMat</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.Max(System.IntPtr,System.Double,System.IntPtr,System.IntPtr)">
            <summary>
            Computes per-element maximum of GpuMat and scalar (dst = max(src1, src2))
            </summary>
            <param name="src1">The first GpuMat</param>
            <param name="src2">The scalar</param>
            <param name="dst">The result GpuMat</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.Threshold(System.IntPtr,System.IntPtr,System.Double,System.Double,Emgu.CV.CvEnum.THRESH,System.IntPtr)">
            <summary>
            Applies fixed-level thresholding to single-channel array. The function is typically used to get bi-level (binary) image out of grayscale image or for removing a noise, i.e. filtering out pixels with too small or too large values. There are several types of thresholding the function supports that are determined by thresholdType
            </summary>
            <param name="src">Source array (single-channel, 8-bit of 32-bit floating point). </param>
            <param name="dst">Destination array; must be either the same type as src or 8-bit. </param>
            <param name="threshold">Threshold value</param>
            <param name="maxValue">Maximum value to use with CV_THRESH_BINARY and CV_THRESH_BINARY_INV thresholding types</param>
            <param name="thresholdType">Thresholding type</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.Filter2D(System.IntPtr,System.IntPtr,System.IntPtr,System.Drawing.Point,System.IntPtr)">
            <summary>
            Applies arbitrary linear filter to the image. In-place operation is supported. When the aperture is partially outside the image, the function interpolates outlier pixel values from the nearest pixels that is inside the image
            </summary>
            <param name="src">The source GpuMat</param>
            <param name="dst">The destination GpuMmage</param>
            <param name="kernel">Convolution kernel, single-channel floating point matrix (e.g. Emgu.CV.Matrix). If you want to apply different kernels to different channels, split the gpu image into separate color planes and process them individually</param>
            <param name="anchor">The anchor of the kernel that indicates the relative position of a filtered point within the kernel. The anchor shoud lie within the kernel. The special default value (-1,-1) means that it is at the kernel center</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.Sobel(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Double,System.IntPtr)">
            <summary>
            Applies generalized Sobel operator to the image
            </summary>
            <param name="src">The source GpuMat</param>
            <param name="dst">The resulting GpuMat</param>
            <param name="dx">Order of the derivative x</param>
            <param name="dy">Order of the derivative y</param>
            <param name="ksize">Size of the extended Sobel kernel</param>
            <param name="scale">Optional scale, use 1 for default.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.Laplacian(System.IntPtr,System.IntPtr,System.Int32,System.Double,System.IntPtr)">
            <summary>
            Applies Laplacian operator to the GpuMat
            </summary>
            <param name="src">The source GpuMat</param>
            <param name="dst">The resulting GpuMat</param>
            <param name="ksize">Either 1 or 3</param>
            <param name="scale">Optional scale. Use 1.0 for default</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.GaussianBlur(System.IntPtr,System.IntPtr,System.Drawing.Size,System.Double,System.Double,System.IntPtr)">
            <summary>
            Smooths the GpuMat using Gaussian filter.
            </summary>
            <param name="src">The source GpuMat</param>
            <param name="dst">The smoothed GpuMat</param>
            <param name="ksize">The size of the kernel</param>
            <param name="sigma1">This parameter may specify Gaussian sigma (standard deviation). If it is zero, it is calculated from the kernel size.</param>
            <param name="sigma2">In case of non-square Gaussian kernel the parameter may be used to specify a different (from param3) sigma in the vertical direction. Use 0 for default</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.WarpAffine(System.IntPtr,System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.INTER,System.IntPtr)">
            <summary>
            Warps the image using affine transformation
            </summary>
            <param name="src">The source GpuMat</param>
            <param name="dst">The destination GpuMat</param>
            <param name="M">The 2x3 transformation matrix (pointer to CvArr)</param>
            <param name="flags">Supports NN, LINEAR, CUBIC</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.WarpPerspective(System.IntPtr,System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.INTER,System.IntPtr)">
            <summary>
            Warps the image using perspective transformation
            </summary>
            <param name="src">The source GpuMat</param>
            <param name="dst">The destination GpuMat</param>
            <param name="M">The 2x3 transformation matrix (pointer to CvArr)</param>
            <param name="flags">Supports NN, LINEAR, CUBIC</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.Remap(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            DST[x,y] = SRC[xmap[x,y],ymap[x,y]] with bilinear interpolation.
            </summary>
            <param name="src">The source GpuMat. Supports CV_8UC1, CV_8UC3 source types. </param>
            <param name="dst">The dstination GpuMat. Supports CV_8UC1, CV_8UC3 source types. </param>
            <param name="xmap">The xmap. Supports CV_32FC1 map type.</param>
            <param name="ymap">The ymap. Supports CV_32FC1 map type.</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.MeanShiftFiltering(System.IntPtr,System.IntPtr,System.Int32,System.Int32,Emgu.CV.Structure.MCvTermCriteria)">
            <summary>
            Performs mean-shift filtering for each point of the source image. It maps each point of the source
            image into another point, and as the result we have new color and new position of each point.
            </summary>
            <param name="src">Source GpuImage. Only CV 8UC4 images are supported for now.</param>
            <param name="dst">Destination GpuImage, containing color of mapped points. Will have the same size and type as src.</param>
            <param name="sp">Spatial window radius.</param>
            <param name="sr">Color window radius.</param>
            <param name="criteria">Termination criteria.</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.MeanShiftProc(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,System.Int32,Emgu.CV.Structure.MCvTermCriteria)">
            <summary>
            Performs mean-shift procedure and stores information about processed points (i.e. their colors
            and positions) into two images.
            </summary>
            <param name="src">Source GpuImage. Only CV 8UC4 images are supported for now.</param>
            <param name="dstr">Destination GpuImage, containing color of mapped points. Will have the same size and type as src.</param>
            <param name="dstsp">Destination GpuImage, containing position of mapped points. Will have the same size as src and CV 16SC2 type.</param>
            <param name="sp">Spatial window radius.</param>
            <param name="sr">Color window radius.</param>
            <param name="criteria">Termination criteria.</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.MeanShiftSegmentation(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,Emgu.CV.Structure.MCvTermCriteria)">
            <summary>
            Performs mean-shift segmentation of the source image and eleminates small segments.
            </summary>
            <param name="src">Source GpuImage. Only CV 8UC4 images are supported for now.</param>
            <param name="dst">Segmented Image. Will have the same size and type as src. Note that this is an Image type and not GpuImage type</param>
            <param name="sp">Spatial window radius.</param>
            <param name="sr">Color window radius.</param>
            <param name="minsize">Minimum segment size. Smaller segements will be merged.</param>
            <param name="criteria">Termination criteria.</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.Integral(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Computes the integral image and integral for the squared image
            </summary>
            <param name="src">The source GpuMat, supports only CV_8UC1 source type</param>
            <param name="sum">The sum GpuMat, supports only CV_32S source type, but will contain unsigned int values</param>
            <param name="sqsum">The sqsum GpuMat, supports only CV32F source type.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.Integral(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Computes the integral image
            </summary>
            <param name="src">The source GpuMat, supports only CV_8UC1 source type</param>
            <param name="sum">The sum GpuMat, supports only CV_32S source type, but will contain unsigned int values</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.SqrIntegral(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Computes squared integral image 
            </summary>
            <param name="src">The source GpuMat, supports only CV_8UC1 source type</param>
            <param name="sqsum">The sqsum GpuMat, supports only CV32F source type.</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or IntPtr.Zero to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.CornerHarris(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Double,Emgu.CV.CvEnum.BORDER_TYPE)">
            <summary>
            Runs the Harris edge detector on image. Similarly to cvCornerMinEigenVal and cvCornerEigenValsAndVecs, for each pixel it calculates 2x2 gradient covariation matrix M over block_size x block_size neighborhood. Then, it stores
            det(M) - k*trace(M)^2
            to the destination image. Corners in the image can be found as local maxima of the destination image.
            </summary>
            <param name="image">Input GpuMat</param>
            <param name="harrisResponce">GpuMat to store the Harris detector responces. Should have the same size as <paramref name="image"/>. </param>
            <param name="blockSize">Neighborhood size </param>
            <param name="kSize"></param>
            <param name="k">Harris detector free parameter.</param>
            <param name="borderType">Boreder type, use REFLECT101 for default</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.Dft(System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.CV_DXT)">
             <summary>
             Performs a forward or inverse discrete Fourier transform (1D or 2D) of floating point matrix.
             Param dft_size is the size of DFT transform.
             
             If the source matrix is not continous, then additional copy will be done,
             so to avoid copying ensure the source matrix is continous one. If you want to use
             preallocated output ensure it is continuous too, otherwise it will be reallocated.
            
             Being implemented via CUFFT real-to-complex transform result contains only non-redundant values
             in CUFFT's format. Result as full complex matrix for such kind of transform cannot be retrieved.
            
             For complex-to-real transform it is assumed that the source matrix is packed in CUFFT's format.
             </summary>
             <param name="src">The source GpuMat</param>
             <param name="dst">The resulting GpuMat of the DST, must be pre-allocated and continious. If single channel, the result is real. If double channel, the result is complex</param>
             <param name="flags">DFT flags</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuInvoke.HistEven(System.IntPtr,System.Int32,System.Int32,System.Int32)">
            <summary>
            Calculates histogram with evenly distributed bins for signle channel source.
            </summary>
            <param name="src">The source GpuMat. Supports CV_8UC1, CV_16UC1 and CV_16SC1 types.</param>
            <param name="histSize">The size of histogram (number of levels)</param>
            <param name="lowerLevel">The lower level</param>
            <param name="upperLevel">The upper level</param>
            <returns>Histogram with evenly distributed bins</returns>
        </member>
        <member name="P:Emgu.CV.GPU.GpuInvoke.HasCuda">
            <summary>
            Return true if Cuda is found on the system
            </summary>
        </member>
        <member name="T:Emgu.CV.GPU.GpuStereoBM">
            <summary>
            Use Block Matching algorithm to find stereo correspondence
            </summary>
        </member>
        <member name="M:Emgu.CV.GPU.GpuStereoBM.#ctor(Emgu.CV.GPU.GpuStereoBM.PresetType,System.Int32,System.Int32)">
            <summary>
            Create a stereoBM 
            </summary>
            <param name="preset">Preset type</param>
            <param name="numberOfDisparities">The number of disparities. Must be multiple of 8. Use 64 for default </param>
            <param name="winSize">The SAD window size</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuStereoBM.FindStereoCorrespondence(Emgu.CV.GPU.GpuImage{Emgu.CV.Structure.Gray,System.Byte},Emgu.CV.GPU.GpuImage{Emgu.CV.Structure.Gray,System.Byte},Emgu.CV.GPU.GpuImage{Emgu.CV.Structure.Gray,System.Byte},Emgu.CV.GPU.Stream)">
            <summary>
            Computes disparity map for the input rectified stereo pair.
            </summary>
            <param name="left">The left single-channel, 8-bit image</param>
            <param name="right">The right image of the same size and the same type</param>
            <param name="disparity">The disparity map</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuStereoBM.DisposeObject">
            <summary>
            Release the stereo state and all the memory associate with it
            </summary>
        </member>
        <member name="T:Emgu.CV.GPU.GpuStereoBM.PresetType">
            <summary>
            Preset type
            </summary>
        </member>
        <member name="F:Emgu.CV.GPU.GpuStereoBM.PresetType.BasicPreset">
            <summary>
            Basic
            </summary>
        </member>
        <member name="F:Emgu.CV.GPU.GpuStereoBM.PresetType.PrefilterXSobel">
            <summary>
            prefilter xsobel
            </summary>
        </member>
        <member name="T:Emgu.CV.GPU.GpuStereoConstantSpaceBP">
            <summary>
            A Constant-Space Belief Propagation Algorithm for Stereo Matching.
            Qingxiong Yang, Liang Wang, Narendra Ahuja.
            http://vision.ai.uiuc.edu/~qyang6/
            </summary>
        </member>
        <member name="M:Emgu.CV.GPU.GpuStereoConstantSpaceBP.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            A Constant-Space Belief Propagation Algorithm for Stereo Matching
            </summary>
            <param name="ndisp">The number of disparities. Use 128 as default</param>
            <param name="iters">The number of BP iterations on each level. Use 8 as default.</param>
            <param name="levels">The number of levels. Use 4 as default</param>
            <param name="nrPlane">The number of active disparity on the first level. Use 4 as default.</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuStereoConstantSpaceBP.FindStereoCorrespondence(Emgu.CV.GPU.GpuImage{Emgu.CV.Structure.Gray,System.Byte},Emgu.CV.GPU.GpuImage{Emgu.CV.Structure.Gray,System.Byte},Emgu.CV.GPU.GpuImage{Emgu.CV.Structure.Gray,System.Byte},Emgu.CV.GPU.Stream)">
            <summary>
            Computes disparity map for the input rectified stereo pair.
            </summary>
            <param name="left">The left single-channel, 8-bit image</param>
            <param name="right">The right image of the same size and the same type</param>
            <param name="disparity">The disparity map</param>
            <param name="stream">Use a Stream to call the function asynchronously (non-blocking) or null to call the function synchronously (blocking).</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuStereoConstantSpaceBP.DisposeObject">
            <summary>
            Release the unmanaged memory
            </summary>
        </member>
        <member name="T:Emgu.CV.GPU.GpuSURFDetector">
            <summary>
            A SURF detector using GPU
            </summary>
        </member>
        <member name="M:Emgu.CV.GPU.GpuSURFDetector.#ctor">
            <summary>
            Create a GPU SURF detector using the default parameters
            </summary>
        </member>
        <member name="M:Emgu.CV.GPU.GpuSURFDetector.#ctor(Emgu.CV.Structure.MCvSURFParams,System.Single)">
            <summary>
            Create a GPU SURF detector using the default parameters
            </summary>
            <param name="detector">The surf detector where the parameters will be borrow from</param>
            <param name="FeaturesRatio">Max features = featuresRatio * img.size().srea(). Use 0.01 for default</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuSURFDetector.#ctor(System.Single,System.Int32,System.Int32,System.Boolean,System.Single,System.Boolean)">
            <summary>
            Create a GPU SURF detector
            </summary>
            <param name="hessianThreshold">The interest operator threshold. Use 100 for default</param>
            <param name="nOctaves">The number of octaves to process. Use 4 for default</param>
            <param name="nIntervals">The number of intervals in each octave. Use 4 for default</param>
            <param name="extended">True, if generate 128-len descriptors, false - 64-len descriptors. Use true for default.</param>
            <param name="featuresRatio">Max features = featuresRatio * img.size().srea(). Use 0.01 for default</param>
            <param name="upright">Use false for default. If set to true, the orientation is not computed for the keypoints</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuSURFDetector.DetectKeyPointsRaw(Emgu.CV.GPU.GpuImage{Emgu.CV.Structure.Gray,System.Byte},Emgu.CV.GPU.GpuImage{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            Detect keypoints in the GpuImage
            </summary>
            <param name="img">The image where keypoints will be detected from</param>
            <param name="mask">The optional mask, can be null if not needed</param>
            <returns>
            The keypoints GpuMat that will have 1 row.
            keypoints.at&lt;float[6]&gt;(1, i) contains i'th keypoint
            format: (x, y, size, response, angle, octave)
            </returns>
        </member>
        <member name="M:Emgu.CV.GPU.GpuSURFDetector.DetectKeyPoints(Emgu.CV.GPU.GpuImage{Emgu.CV.Structure.Gray,System.Byte},Emgu.CV.GPU.GpuImage{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            Detect keypoints in the GpuImage
            </summary>
            <param name="img">The image where keypoints will be detected from</param>
            <param name="mask">The optional mask, can be null if not needed</param>
            <returns>An array of keypoints</returns>
        </member>
        <member name="M:Emgu.CV.GPU.GpuSURFDetector.DownloadKeypoints(Emgu.CV.GPU.GpuMat{System.Single},Emgu.CV.Util.VectorOfKeyPoint)">
            <summary>
            Obtain the keypoints array from GpuMat
            </summary>
            <param name="src">The keypoints obtained from DetectKeyPointsRaw</param>
            <param name="dst">The vector of keypoints</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuSURFDetector.UploadKeypoints(Emgu.CV.Util.VectorOfKeyPoint,Emgu.CV.GPU.GpuMat{System.Single})">
            <summary>
            Ontain a GpuMat from the keypoints array
            </summary>
            <param name="src">The keypoints array</param>
            <param name="dst">A GpuMat that represent the keypoints</param>
        </member>
        <member name="M:Emgu.CV.GPU.GpuSURFDetector.ComputeDescriptorsRaw(Emgu.CV.GPU.GpuImage{Emgu.CV.Structure.Gray,System.Byte},Emgu.CV.GPU.GpuImage{Emgu.CV.Structure.Gray,System.Byte},Emgu.CV.GPU.GpuMat{System.Single})">
            <summary>
            Compute the descriptor given the image and the point location
            </summary>
            <param name="image">The image where the descriptor will be computed from</param>
            <param name="mask">The optional mask, can be null if not needed</param>
            <param name="keyPoints">The keypoint where the descriptor will be computed from. The order of the keypoints might be changed unless the GPU_SURF detector is UP-RIGHT.</param>
            <returns>The image features founded on the keypoint location</returns>
        </member>
        <member name="M:Emgu.CV.GPU.GpuSURFDetector.DisposeObject">
            <summary>
            Release the unmanaged resource associate to the Detector
            </summary>
        </member>
        <member name="P:Emgu.CV.GPU.GpuSURFDetector.DescriptorSize">
            <summary>
            Return the size of the descriptor (64/128)
            </summary>
        </member>
        <member name="T:Emgu.CV.GPU.Stream">
            <summary>
            Encapculates Cuda Stream. Provides interface for async coping.
            Passed to each function that supports async kernel execution.
            Reference counting is enabled
            </summary>
        </member>
        <member name="M:Emgu.CV.GPU.Stream.#ctor">
            <summary>
            Create a new Cuda Stream
            </summary>
        </member>
        <member name="M:Emgu.CV.GPU.Stream.WaitForCompletion">
            <summary>
            Wait for the completion
            </summary>
        </member>
        <member name="M:Emgu.CV.GPU.Stream.Copy``1(Emgu.CV.GPU.GpuMat{``0},Emgu.CV.GPU.GpuMat{``0})">
            <summary>
            Copy the src GpuMat to dst GpuMat asyncronously
            </summary>
            <typeparam name="TDepth">The type of depth for the GpuMat</typeparam>
            <param name="src">The source matrix</param>
            <param name="dst">The destination matrix. Must be the same size and same number of channels</param>
        </member>
        <member name="M:Emgu.CV.GPU.Stream.DisposeObject">
            <summary>
            Release the stream
            </summary>
        </member>
        <member name="P:Emgu.CV.GPU.Stream.Completed">
            <summary>
            Check if the stream is completed
            </summary>
        </member>
    </members>
</doc>
